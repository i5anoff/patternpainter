<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Scifidots_01</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<script src="../build/three.js"></script>

		<script src="../js/shaders/CopyShader.js"></script>
		<script src="../js/shaders/BokehShader.js"></script>
		<script src="../js/shaders/FXAAShader.js"></script>
		<script src="../js/shaders/SMAAShader.js"></script>
		<script src="../js/shaders/TiltShiftShader.js"></script>
		<script src="../js/shaders/FilmShader.js"></script>
		<script src="../js/shaders/ConvolutionShader.js"></script>
		<script src="../js/shaders/LuminosityHighPassShader.js"></script>

		<script src="../js/postprocessing/EffectComposer.js"></script>
		<script src="../js/postprocessing/RenderPass.js"></script>
		<script src="../js/postprocessing/ShaderPass.js"></script>
		<script src="../js/postprocessing/MaskPass.js"></script>
		<script src="../js/postprocessing/BokehPass.js"></script>
		<script src="../js/postprocessing/SMAAPass.js"></script>
		<script src="../js/postprocessing/FilmPass.js"></script>
		<script src="../js/postprocessing/UnrealBloomPass.js"></script>

		<script src="../js/controls/OrbitControls.js"></script>
		<script src="../js/Detector.js"></script>
		<script src="../js/libs/stats.min.js"></script>
		<script src='../js/libs/dat.gui.min.js'></script>

		<script src="scripts/Util.js"></script>

		<link rel="stylesheet" type="text/css" href="./style/common.css">
	</head>

	<body>
		<div id="container"></div>
		
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var stats, count = 1;
			var camera, scene, renderer;
			var sphereGroup;

			var w = window.innerWidth;
			var h = w > 1400 ? 600 : 480;

			var postprocessing = {};

			var guiParams  = {
				test: 10,
				fov: 75,
				tiltFocus: 0.5,
				tiltAmount: 0.006,
				tiltBrightness: 0.65,
				onPostProcess: true,
			};

			init();
			initPainterUtils( renderer );
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, w / h, 1, 5000 );
				camera.position.z = 200;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( w, h );
				renderer.autoClear = false;


				var line_mat = new THREE.LineDashedMaterial( { 
					color : 0x00aaff,
					opacity: 0.3,
					transparent: true,
					blending: THREE['AdditiveBlending']
				} );


				var loader = new THREE.TextureLoader();

				sphereGroup = new THREE.Group;

				var geo = new THREE.SphereGeometry( 0.7, 20, 10 );

				var spriteMaterial = new THREE.SpriteMaterial( { 
					map: loader.load('../textures/lensflare_cyan.png'),
					color: 0xffffff,
					opacity: 0.7,
					transparent: true,
					blending: THREE['AdditiveBlending']
				} );


				for( var i=0; i<500; ++i ) {
					
					var sphere = new THREE.Sprite( spriteMaterial );

					sphere.position.set( Math.random()*600-300, Math.random()*400-200, Math.random()*200-100  );

					sphereGroup.add( sphere );

				}

				for( var i=0; i<200; ++i ) {

					var source = sphereGroup.children[i];

					var sourcePosition = source.position;

					for( var j=0; j<100; ++j ) {

						var destPosition = sphereGroup.children[j].position;

						if( sourcePosition.distanceTo( destPosition ) < 100 && i != j ) {

							var scale = Math.random() * 22.0 - 6.0;

							source.scale.set( scale, scale, 0 );

							var line_geo = new THREE.BufferGeometry().setFromPoints([ sourcePosition, destPosition ]);
							var line = new THREE.Line( line_geo, line_mat );
							scene.add( line );

						}

					}

				}

				scene.add( sphereGroup );

				

				initPostprocessing();


				//init GUI				
				var gui = new dat.GUI();
				gui.add( guiParams, 'onPostProcess' ).onChange( function (value) {
					guiParams.onPostProcess = value;
				})
				gui.add( guiParams, "fov", 25, 125, 75 ).onChange( onParamsChange ).step(2);
				gui.add( guiParams, "tiltFocus", 0, 1, 0.5 ).onChange( onParamsChange ).step(0.05);
				gui.add( guiParams, "tiltAmount", 0, 0.02, 0.005 ).onChange( onParamsChange ).step(0.001);
				gui.add( guiParams, "tiltBrightness", 0, 2, 0.5 ).onChange( onParamsChange );
				gui.open();

				onParamsChange();


				// other
				stats = new Stats();
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				container.appendChild( stats.dom );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}



			function onParamsChange () {
				postprocessing.tilt.uniforms.focusPos.value = guiParams.tiltFocus;
				postprocessing.tilt.uniforms.amount.value = guiParams.tiltAmount;
				postprocessing.tilt.uniforms.brightness.value = guiParams.tiltBrightness;

				camera.fov = guiParams.fov;
				camera.updateProjectionMatrix();

			}


			function onWindowResize() {

				camera.aspect = w / h;
				camera.updateProjectionMatrix();

				renderer.setSize( w, h );
				postprocessing.composer.setSize( w, h );
			}


			function initPostprocessing() {

				var renderPass = new THREE.RenderPass( scene, camera );
				var effectFilmPass = new THREE.FilmPass( 6, 0.9, 648, false );
				var effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / w, 1 / h );
				var tiltShiftPass = new THREE.ShaderPass( THREE.VerticalTiltShiftShader );
				var effect_bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( w, h ), 2.8, 0.67, 0.23 ); 

				// which pass is the final pass
				effectFXAA.renderToScreen = true;

				var composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderPass );
				composer.addPass( effectFilmPass );
				composer.addPass( tiltShiftPass );
				composer.addPass( effectFXAA );
				// composer.addPass( effect_bloomPass );
			
				postprocessing.composer = composer;
				postprocessing.tilt = tiltShiftPass;

			}

			function animate() {

				requestAnimationFrame( animate, renderer.domElement );

				stats.begin();
				render();
				stats.end();

			}

			function render() {

				count++;

				var factor = count*Math.PI/180;


				for( var i=0; i<sphereGroup.children.length; ++i ) {

						var factor = ( count + i*2 )*Math.PI/180;

						// sphereGroup.children[i].scale.set( Math.sin(factor)*2, Math.sin(factor)*2, Math.sin(factor)*1 );


				}


				if( guiParams.onPostProcess ) {
					postprocessing.composer.render( 0.1 );
				}else{
					renderer.render( scene, camera );
				}


			}

		</script>


	</body>
</html>
